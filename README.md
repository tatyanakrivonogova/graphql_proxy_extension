# graphql_proxy_extension
GraphQL-extension for PostgresQL

# Общая задача
Есть заказчик, у которого есть действующие приложения с использованием GraphQL API. GraphQL - это всего лишь интерфейс, сами данные могут храниться где угодно и как угодно, кроме того, могут располагаться в разных местах. Через GraphQL из приложения можно за один запрос отправлять и получать данные, необходимые и достаточные для работы функций приложения. Допустим, заказчик понял, что больше не хочет работать с GraphQL и решил перейти на PostgresQL. Конечно же, он не будет переписывать части кода своих приложений, которые относятся к работе с базой данных. Поэтому заказчик хочет использовать прокси GraphQL-PostgresQL. Прокси будет представлять собой сервер, запускающийся из расширения при запуске PostgresQL (скорее всего на том же порту, где работал GraphQL). Этот сервер должен вести себя точно так же, как вел себя сервер GraphQL, с точки зрения пользовательского приложения. То есть всегда нам нужно помнить о соблюдении протокола (или же спецификации GraphQL: https://spec.graphql.org/draft/). Мы должны (в идеале) научиться принимать запросы, обрабатывать их и выдавать результат клиенту точно так же, как это делает сервер GraphQL. При этом на самом деле данные будут храниться в базе данных PostgresQL.

# Требования
1. Одновременная обработка многих клиентов
2. Преобразование схемы данных в базе Postgres в схему для GraphQL
3. Хранение актуальной GraphQL-схемы данных
4. Парсинг GraphQL-запросов
5. Валидация приходящих от клиентов запросов в соответствии с текущей схемой данных
6. Преобразование GraphQL-запросов в запросы, которые понимает Postgres
7. Сохранение главного принципа GraphQL API - мы должны за один запрос отдавать все необходимые данные и не отдавать ничего лишнего
8. Преобразование результата выполнения запроса в json-формат
9. Правильная обработка ошибок (GraphQL отдает ошибки в виде json-а)


# Запуск
gcc client.c -o client
./client 127.0.0.1 7879

Пример HTTP-запроса:
GET /query HTTP/1.0
Content-Length: 0

query findVideos {
  videos {
    id
    title
    url
    author {
      id
      name
    }
  }
}

Сервер отправляет обратно клиенту тело HTTP-запроса, на стороне клиента ответ сохраняется в файле response.
В логах сервера можно посмотреть, во что распарсился HTTP-запрос: метод, ресурс, версия протокола, количество заголовков, их имена и значения, тело запроса (если есть).